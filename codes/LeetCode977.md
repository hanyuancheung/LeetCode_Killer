# LeetCode 第 977 号问题：有序数组的平方

**from zahnghanyuan**

题目来源于 LeetCode 上第 977 号问题：有序数组的平方。题目难度为 easy。

### 题目描述

给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。

提示：

1 <= A.length <= 10000
-10000 <= A[i] <= 10000
A 已按非递减顺序排序。

**示例1:**

```
输入：[-4,-1,0,3,10]
输出：[0,1,9,16,100]
```

**示例1:**

```
输入：[-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

### 题目解析1

1. 题目比较简单，直接暴力求解

2. 将每个元素直接变成他的平方，然后排序即可

### 代码实现1

```java
class Solution {
    public int[] sortedSquares(int[] A) {
        int n = A.length;
        for (int i = 0;i < n;i++){
            A[i] = A[i] * A[i];
        }
        Arrays.sort(A);
        return A;
    }
}
```

时间复杂度：O(NlogN)，其中 N 是数组 A 的长度。

空间复杂度：O(N)。

### 结果描述1

执行用时：2 ms, 在所有 Java 提交中击败了66.07%的用户

内存消耗：40.3 MB, 在所有 Java 提交中击败了89.56%的用户

### 题目解析2

1. 因为数组A已经排序好了，如果我们平方可能会打乱顺序，重新排序时间复杂度最好是O(nlogn)

2. 直接找到绝对值最小的数，然后通过设置双指针，j向后遍历，i先前遍历，依次将每个元素平方

3. 同时比较两个平方后的数的大小，较小的存入数组，然后较小的数继续遍历

4. 注意：两边任意一边结束遍历会使while循环结束，所以我们还需要考虑到还有一边没有结束的情况，这一边再继续遍历。

### 代码实现2

```java
class Solution {
    public int[] sortedSquares(int[] A) {
        int n = A.length;
        int j  = 0;
        while(j < n && A[j] < 0){
            j++;                    //找到绝对值最小的j，然后开始向后遍历
        }
        int i = j - 1;              //找到合适的i，开始向前遍历
        int t = 0;                  //作为新数组的index
        int[] ans = new int[n];
        while(i >= 0 && j < n){
            if (A[i] * A[i] < A[j] * A[j]){
                ans[t++] = A[i] * A[i];
                i--;
            }else{
                ans[t++] = A[j] * A[j];
                j++;
            }
        }
        while(i >= 0){              //如果左边没有遍历完，继续向左遍历
            ans[t++] = A[i] * A[i];
            i--;
        }
        while(j < n){               //如果右边没有遍历完，继续向右遍历
            ans[t++] = A[j] * A[j];
            j++;
        }
        return ans;
    }
}
```

时间复杂度：O(N)，其中 N 是数组 A 的长度。
空间复杂度：O(N)。

### 结果描述2

执行用时：2 ms, 在所有 Java 提交中击败了66.07%的用户

内存消耗：40.7 MB, 在所有 Java 提交中击败了22.06%的用户