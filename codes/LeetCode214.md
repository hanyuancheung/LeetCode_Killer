# LeetCode 第 214 号问题：最短回文串

**from Wilfred**

题目来源于 LeetCode 上第 214 号问题：最短回文串。题目难度为 Hard，目前通过率为 34.5%。

### 题目描述

给定一个字符串 `s`，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

**示例1:**

```
输入: "aacecaaa"
输出: "aaacecaaa"
```

**示例2:**

```
输入: "abcd"
输出: "dcbabcd"
```

### 题目解析

题目描述非常简单，也不会有歧义，只需要注意是在字符串**前**加字符串，而不是**两侧**或者**后**。我们能想到的最简单的创造回文串的方法无非就是将其翻转，然后添加上去，但是题目要求最短，也就是要我们找出翻转之后重叠的部分，比如：`"abcd"` 翻转之后为 `"dcba"`，重叠一个 `'a'`，所以结果为 `"dcb" + "abcd" = "dcbabcd"`。

自然而然地，我们就会想到暴力法，一个个匹配，找出最长的重叠部分，但是这种方法效率拉胯，作为 Hard 难度的题目不可能直接给过，暴力法的结果就是超时。所以我们要进行优化，暴力法的问题就在于每次步进 `1`，导致做了许多无用功，安全且高效地跳过不需要比较的部分就能大大改善查找效率，这里我们采用的是 KMP 算法（的一部分）。

#### KMP 算法

假设我们在字符串 `s` 中查找是否有字符串 `p`，设整数 `i, j` 分别为字符串 `s, p` 中的游标。我们会发现暴力法每次匹配失败，`i, j` 都会回退，其中 `i` 的步进为 `1`，`j` 则每次都回到 `0`。KMP 算法的主要思想就是我让 `i` 不回退，只有 `j` 往回移动，而且也不一定移动到 `0`，只要能限制 `j` 移动的次数就可以确保时间复杂度够低。

假设我们有一个长度为 `n` 的整型数组 `next`，其中 `next[i]` 表示 `s[0] ~ s[i]` 的字符串中相同的前缀以及后缀的最大长度。以 `"ababcabcd"` 为例：

| `i`  | 前缀                                | 后缀                                | 最大长度 |
| ---- | ----------------------------------- | ----------------------------------- | -------- |
| `0`  | 无                                  | 无                                  | 0        |
| `1`  | `"a"`                               | `"b"`                               | 0        |
| `2`  | `"a", "ab"`                         | `"a", "ba"`                         | 1        |
| `3`  | `"a", "ab", "aba"`                  | `"b", "ab", "bab"`                  | 2        |
| `4`  | `"a", "ab", "aba", "abab"`          | `"c", "ba", "abc", "babc"`          | 0        |
| `5`  | `"a", "ab", "aba", "abab", "ababc"` | `"a", "ca", "bca", "abca", "babca"` | 1        |
| `6`  | ...                                 | ...                                 | 2        |
| `7`  | ...                                 | ...                                 | 0        |
| `8`  | ...                                 | ...                                 | 0        |

这样，假如字符串 `p = "ababa"`，那么在第一次匹配时，在 `i = j = 4` 时会失败，但这时 `i` 就不用回到 `1` 再开始匹配，因为 `next` 数组已经告诉它中间有一段你匹配不上，直接跳到可以匹配的部分就好，二者匹配的部分就是前后缀重复的部分（`s` 前后缀相同 + `p` 前缀和 `s` 前缀相同 =  `p` 前缀和 `s` 后缀相同），所以 `i` 不用回到 `1`，待在原地就好，而 `j` 也不用回到 `0`，而是回到 `2`（ `p` 前缀 `"ab"` 和 `s` 后缀 `"ab"` 相同）。

有了 `next` 数组我们可以发现，`i, j` 共有三种情况：

1. `i, j` 同时自增 `1`（字符匹配成功）
2. `i` 不变，`j` 回退（ `p` 非首字符匹配失败）
3. `i` 自增 `1`，`j` 不变（ `p` 首字符匹配失败）

简单分析我们可以发现，`j` 最多自增 `min(n, m)` 次，所以 `j` 最多回退 `min(n, m)` 次，也就是说 `j` 最多变化 `2*min(n, m)` 次，时间复杂度是线性的。

生成 `next` 我们使用和上方类似的思想，将它自己和自己匹配就可以找出相同的前后缀。依旧使用 `i, j` 作为游标，`i` 自增时更新 `next`，而 `j` 回退时用到的 `next` 在之前已经逐步计算出来了（动态规划），所以时间复杂度和上面的算法相仿，为 `O(n)`，那么整体的时间复杂度就是 `O(n+m)`。

讲完了 KMP 算法，我们发现 KMP 算法主要就是在计算相同的前后缀，而我们这题其实也是在计算相同的前后缀：将 `s` 翻转后去掉相同的部分，去掉的部分即是两个字符串相同的前后缀。所以我们只需要 KMP 算法的一半——`next` 数组即可。我们将原字符串和翻转后的字符串相连，其中用一个特殊字符分隔，计算其 `next` 数组，数组中的最后一项就是重复的最长前后缀的长度。

### 代码实现

```java
import java.lang.StringBuffer;

class Solution {
    public String shortestPalindrome(String s) {
        if (s.length() <= 1)
            return s;
        String sr = new StringBuffer(s).reverse().toString();
        int[] next = getNext(s + "$" + sr);
        return sr.substring(0, next.length / 2 - next[next.length - 1]) + s;
    }

    public int[] getNext(String s) {
        int len = s.length();
        int[] next = new int[len];
        next[0] = 0;
        int i = 1, j = 0;
        while (i < len) {
            if (s.charAt(i) == s.charAt(j))
                next[i++] = ++j;
            else if (j != 0)
                j = next[j - 1];
            else
                next[i++] = 0;
        }
        return next;
    }
}
```
