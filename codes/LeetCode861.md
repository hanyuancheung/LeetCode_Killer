# LeetCode 第 861 号问题：翻转矩阵后的得分

**from Wilfred**

题目来源于 LeetCode 上第 861 号问题：翻转矩阵后的得分。题目难度为 Medium，目前通过率为 74.0%。

### 题目描述

有一个二维矩阵 `A` 其中每个元素的值为 `0` 或 `1` 。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 `0` 都更改为 `1`，将所有 `1` 都更改为 `0`。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

**返回尽可能高的分数。**

**示例1:**

```
输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
```

### 题目解析

这题非常有意思，乍看之下类似求矩阵中 `1` 的最多个数，但是该题将每行转换为二进制数字，所以就赋予了每一**列**不同的权重，靠左的 `1` 越多收益越大，从而可以适当牺牲右侧 `1` 的个数。

我们不难发现每行的行首如果是 `1`，则该行将达到局部最优，翻转之后会变小。所以如果我们有一个最优的矩阵，第一列一定全都是 `1`，否则翻转该行将得到更优的矩阵，所以我们可以先将每行都翻转成行首为 `1`，因为翻转的顺序不影响结果。

在每行都不能再翻转之后，求解就非常简单了，我们只需要统计每一列 `0` 和 `1` 的个数，多的那一个将是最终该列的 `1` 的个数，再乘上该列的权重就可以得到该列的和，将所有列的和相加即可得到结果。


### 代码实现

```java
class Solution {
    public int matrixScore(int[][] A) {
        int rows = A.length, cols = A[0].length;
        // 每行达到局部最优
        for (int i = 0; i < rows; ++i)
            if (A[i][0] == 0)
                for (int j = 0; j < cols; ++j)
                    A[i][j] = 1 - A[i][j];
        int count = 0, sum = 0;
        for (int i = 0; i < cols; ++i) {
            for (int j = 0; j < rows; ++j)
                count += A[j][i];
            // 权重 * 个数
            sum += (1 << (cols - 1 - i)) * (count > rows / 2 ? count : rows - count);
            count = 0;
        }
        return sum;
    }
}
```
